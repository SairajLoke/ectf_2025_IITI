"""
Author: Ben Janis
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""
import os
import argparse
import base64
import os
import struct
import json

from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.Util.Padding import pad
from cryptography.hazmat.primitives.kdf.hkdf import HKDF


import logging

logging.disable(logging.CRITICAL)

class Encoder:
    def __init__(self, secrets: bytes):
        os.makedirs("design/logs", exist_ok=True)
        
        logging.basicConfig(filename="design/logs/encoder.log", 
                            level=logging.DEBUG, 
                            format="%(asctime)s || %(levelname)s || %(message)s || %(funcName)s || %(lineno)d")

        self.logger = logging.getLogger(__name__)
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        # TODO: parse your secrets data here and run any necessary pre-processing to
        #   improve the throughput of Encoder.encode

        # Load the json of the secrets file
        secrets = json.loads(secrets)

        # Load the example secrets for use in Encoder.encode
        # This will be "EXAMPLE" in the reference design"
        self.secrets = secrets        
        self.channels = self.secrets["channels"] 
        self.root_key = base64.b64decode(self.secrets["root_key"])
        self.encoder_private_key = serialization.load_pem_private_key(self.secrets["encoder_private_key"].encode("utf-8"), password=None)
        self.encoder_public_key = serialization.load_pem_public_key(self.secrets["encoder_public_key"].encode("utf-8"))
        self.decoder_private_key = serialization.load_pem_private_key(self.secrets["decoder_private_key"].encode("utf-8"), password=None)
        self.decoder_public_key = serialization.load_pem_public_key(self.secrets["decoder_public_key"].encode("utf-8"))
        self.signature_private_key = serialization.load_pem_private_key(self.secrets["signature_private_key"].encode("utf-8"), password=None)
        self.signature_public_key = serialization.load_pem_public_key(self.secrets["signature_public_key"].encode("utf-8"))
        self.subscription_key = base64.b64decode(self.secrets["subscription_key"])
        self.channel_keys = self.secrets["channel_keys"]
        for key in self.channel_keys:
            self.channel_keys[key] = base64.b64decode(self.channel_keys[key])
        
        
        self.shared_key = self.encoder_private_key.exchange(ec.ECDH(), self.decoder_public_key) #why create it here again and again during the encode fn call?
        logging.info(f"type: {type(self.root_key)}, root key: {self.root_key}")
        logging.info(f" type: {type(self.encoder_private_key)}, encoder private key: {self.encoder_private_key}")
        logging.info(f"type: {type(self.encoder_public_key)}, encoder public key: {self.encoder_public_key}")
        logging.info(f"d type: {type(self.decoder_private_key)}, decoder private key: {self.decoder_private_key}")
        logging.info(f" type: {type(self.decoder_public_key)}, decoder public key: {self.decoder_public_key}")
        logging.info(f" type: {type(self.signature_private_key)}, signature private key: {self.signature_private_key}")
        logging.info(f" type: {type(self.signature_public_key)}, signature public key: {self.signature_public_key}")
        logging.info(f"type: {type(self.subscription_key)}, subscription key: {self.subscription_key}")
        logging.info(f"channel keys len: {len(self.channel_keys)}, type: {type(self.channel_keys)}, channel keys: {self.channel_keys}")  
        logging.info(f"type: {type(self.shared_key)}, shared key: {self.shared_key}")
        
    
        # self.shared_key = HKDF(
        #             algorithm=hashes.SHA256(),
        #             length=32,
        #             salt=None,
        #             info=b'handshake data',
        #             ).derive(self.temp_key)

        print("BLOCK SIZE: ", AES.block_size)
        print("KEY SIZE: ", len(self.shared_key))
        # print("KEY: SIZE TEMP_KEY: ", len(self.temp_key))
        
        
    def aes_encrypt(self, key: bytes, data: bytes) -> bytes:
        iv = os.urandom(AES.block_size)# 32)
        # cipher_ = AES.new(key.encode("utf-8"), AES.MODE_CBC, iv.encode("utf-8"))
        # ctr = Counter.new(256, initial_value=int.from_bytes(iv, byteorder='big'))# Create an AES cipher object in CTR mode
        # cipher = AES.new(key, AES.MODE_CBC, iv)  #: AES CBC encryption has no padding
        # return base64.b64encode(cipher.encrypt(data))
        logging.info(f"\n")
        logging.info(f"Len of Raw data : {len(data)}, type: {type(data)}, data: {data}")
        logging.info(f"Len of key : {len(key)}, type: {type(key)}, key: {key}")
        logging.info(f"Len of iv : {len(iv)}, type: {type(iv)}, iv: {iv}")
        
        cipher = AES.new(key, AES.MODE_CBC, iv)
        padded = pad(data, AES.block_size) # https://pycryptodome.readthedocs.io/en/latest/src/util/util.html
        logging.info(f"\nPadded data: {padded}")
        
        return iv + cipher.encrypt(padded) #base64.b64encode()  # prepend Init Vect
    
    def ecdh(self, data:bytes) -> bytes:
        return self.aes_encrypt(self.shared_key, data)
    
    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs

        You **may not** change the arguments or returns of this function!

        :param channel: 16b unsigned channel number. Channel 0 is the emergency
            broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
            have no relation to the current timestamp, so you should not compare it
            against the current time. The timestamp is guaranteed to strictly
            monotonically increase (always go up) with subsequent calls to encode

        :returns: The encoded frame, which will be sent to the Decoder
        """
        logging.info(f"frame: {frame}")
        print("channel key: ", len(self.channel_keys[str(channel)]))
        logging.info(f"channel key: {len(self.channel_keys[str(channel)])}")
            
        #encrypt the frame with the channel key
        encrypted_frame = self.aes_encrypt(self.channel_keys[str(channel)], frame)
        print("encrypted frame: ", encrypted_frame)
        logging.info(f"encrypted frame: {encrypted_frame}")
        
        #ecdh encrypption of pkt with the shared key
        # packet_data = {
        #     "channel": channel,
        #     "timestamp": timestamp,
        #     "frame": encrypted_frame #encrypted_frame).decode("utf-8") #encrypted_frame.decode("utf-8") # Convert bytes to string for JSON serialization???
        # }
        # print("packet frame: ", packet_data)
        # print( "data", packet_data["channel"], packet_data["timestamp"], packet_data["frame"])
        # return json.dumps(packet_data).encode("utf-8")
        print("channel: ", channel)
        print("timestamp: ", timestamp)
        print("encrypted frame: ", encrypted_frame)
        
        logging.info(f"channel: {channel}, timestamp: {timestamp}, encrypted frame: {encrypted_frame}")
        logging.info(f"Bytes (bytes(channel) {bytes(channel)}, bytes(5) {bytes(5)} ,bytes(timestamp): , encrypted_frame: {encrypted_frame})")
        
        # return bytes(channel) + bytes(timestamp) + encrypted_frame
        # return bytes(channel) + bytes(timestamp) + encrypted_frame#"hello world".encode("utf-8")...very very wrong...its returning channel number of bytes

        return channel.to_bytes(4, byteorder='little') + timestamp.to_bytes(8, byteorder='little') + encrypted_frame #+ encrypted_frame.decode("utf-8") # Convert bytes to string for JSON serialization???
        
        # packet_cft_bytes = json.dumps(packet_data).encode("utf-8")
        # encrypted_packet = self.ecdh(packet_cft_bytes)
        # return encrypted_packet
        #signin the encrypted pkt
        # signed_certificate = self.signature_private_key.sign(encrypted_packet, ec.ECDSA(hashes.SHA256()))
        # # check len opf signed certificate
        # print("signed certificate len: ", len(signed_certificate))
        # print("signed certificate: ", signed_certificate)
        # import time 
        # time.sleep(5)
        # final_packet = {
        #     "signed_certificate": base64.b64encode(signed_certificate).decode("utf-8"),
        #     "encrypted_packet": base64.b64encode(encrypted_packet).decode("utf-8")
        # }
        # return signed_certificate + encrypted_packet


def main():
    """A test main to one-shot encode a frame

    This function is only for your convenience and will not be used in the final design.

    After pip-installing, you should be able to call this with:
        python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
    parser.add_argument(
        "secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
    )
    parser.add_argument("channel", type=int, help="Channel to encode for")
    parser.add_argument("frame", help="Contents of the frame")
    parser.add_argument("timestamp", type=int, help="64b timestamp to use")
    args = parser.parse_args()

    encoder = Encoder(args.secrets_file.read())
    print(repr(encoder.encode(args.channel, args.frame.encode(), args.timestamp)))
    


if __name__ == "__main__":
    main()
